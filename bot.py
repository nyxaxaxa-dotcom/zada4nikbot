# bot.py
# –¢—Ä–µ–±—É–µ—Ç—Å—è: python-telegram-bot[webhooks] >= 21  (—Å—Ç–∞–≤–∏—Ç—Å—è –∏–∑ requirements.txt)

import json
import os
from pathlib import Path
from typing import Dict, Any, Tuple

from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.error import BadRequest
from telegram.ext import (
    Application, CommandHandler, MessageHandler, CallbackQueryHandler,
    ContextTypes, filters
)

DATA_DIR = Path("./data")
DATA_DIR.mkdir(exist_ok=True)

TOKEN = os.getenv("TG_BOT_TOKEN")
if not TOKEN:
    raise RuntimeError("–ù–µ –∑–∞–¥–∞–Ω TG_BOT_TOKEN –≤ –æ–∫—Ä—É–∂–µ–Ω–∏–∏.")

REM_OPTIONS = {"1": 60 * 60, "3": 3 * 60 * 60, "6": 6 * 60 * 60}

def _user_file(user_id: int) -> Path:
    return DATA_DIR / f"{user_id}.json"

def _ensure_defaults(data: Dict[str, Any]) -> Dict[str, Any]:
    data.setdefault("seq", 0)
    data.setdefault("tasks", {})
    data.setdefault("stats", {"closed": 0})
    return data

def load_tasks(user_id: int) -> Dict[str, Any]:
    fp = _user_file(user_id)
    if fp.exists():
        try:
            return _ensure_defaults(json.loads(fp.read_text(encoding="utf-8")))
        except Exception:
            return {"seq": 0, "tasks": {}, "stats": {"closed": 0}}
    return {"seq": 0, "tasks": {}, "stats": {"closed": 0}}

def save_tasks(user_id: int, data: Dict[str, Any]) -> None:
    data = _ensure_defaults(data)
    fp = _user_file(user_id)
    tmp = fp.with_suffix(".json.tmp")
    tmp.write_text(json.dumps(data, ensure_ascii=False, indent=2), encoding="utf-8")
    tmp.replace(fp)

def progress_bar(done: int, total: int, width: int = 10) -> str:
    total = max(total, 1)
    ratio = min(max(done / total, 0.0), 1.0)
    filled = int(round(ratio * width))
    return "‚ñà" * filled + "‚ñë" * (width - filled)

def task_line(t: Dict[str, Any]) -> str:
    bar = progress_bar(t["done"], t["total"])
    rem = ""
    interval = t.get("reminder_interval")
    if interval:
        mp = {REM_OPTIONS["1"]: "1—á", REM_OPTIONS["3"]: "3—á", REM_OPTIONS["6"]: "6—á"}
        rem = f" ‚Ä¢ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ: {mp.get(interval, str(interval)+'—Å')}"
    return f"{t['name']}  {bar}  {t['done']}/{t['total']}{rem}"

def main_menu_kb() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("‚ûï –ó–∞–¥–∞—á–∞", callback_data="ui:new")],
        [InlineKeyboardButton("üìã –ú–æ–∏ –∑–∞–¥–∞—á–∏", callback_data="ui:list")]
    ])

def reminder_menu_kb(tid: int) -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup([
        [
            InlineKeyboardButton("üîî 1 —á–∞—Å", callback_data=f"t:rem1:{tid}"),
            InlineKeyboardButton("üîî 3 —á–∞—Å–∞", callback_data=f"t:rem3:{tid}"),
            InlineKeyboardButton("üîî 6 —á–∞—Å–æ–≤", callback_data=f"t:rem6:{tid}"),
        ],
        [InlineKeyboardButton("üîï –û—Ç–∫–ª—é—á–∏—Ç—å", callback_data=f"t:remoff:{tid}")],
        [InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data=f"t:open:{tid}")]
    ])

def task_kb(task_id: int, t: Dict[str, Any]) -> InlineKeyboardMarkup:
    buttons = [
        [
            InlineKeyboardButton("Ôºã1", callback_data=f"t:+:{task_id}"),
            InlineKeyboardButton("Ôºç1", callback_data=f"t:-:{task_id}")
        ],
        [
            InlineKeyboardButton("üìù –ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞—Ç—å", callback_data=f"t:ren:{task_id}"),
            InlineKeyboardButton("üî¢ –ó–∞–¥–∞—Ç—å —à–∞–≥–∏", callback_data=f"t:set:{task_id}")
        ],
        [
            InlineKeyboardButton("‚ôªÔ∏è –°–±—Ä–æ—Å", callback_data=f"t:rst:{task_id}"),
            InlineKeyboardButton("üóë –£–¥–∞–ª–∏—Ç—å", callback_data=f"t:del:{task_id}")
        ],
        [
            InlineKeyboardButton("üîî –ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ", callback_data=f"t:rem:{task_id}"),
            InlineKeyboardButton("‚úÖ –ó–∞–∫—Ä—ã—Ç—å", callback_data=f"t:close:{task_id}")
        ],
        [InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="ui:list")],
        [
            InlineKeyboardButton("‚ûï –ù–æ–≤–∞—è", callback_data="ui:new"),
            InlineKeyboardButton("üìã –°–ø–∏—Å–æ–∫", callback_data="ui:list")
        ]
    ]
    if t["done"] >= t["total"]:
        buttons.insert(0, [InlineKeyboardButton("‚úÖ –ì–æ—Ç–æ–≤–æ", callback_data="noop")])
    return InlineKeyboardMarkup(buttons)

def parse_new_payload(text: str) -> Tuple[str, int]:
    parts = text.strip().rsplit("|", 1)
    name = parts[0].strip()
    total = 5
    if len(parts) == 2:
        try:
            total = max(1, int(parts[1].strip()))
        except Exception:
            total = 5
    return name, total

async def safe_edit(query, text: str, reply_markup=None):
    try:
        if query and query.message and query.message.text == text:
            await query.answer()
            return
        await query.edit_message_text(text, reply_markup=reply_markup)
    except BadRequest as e:
        if "Message is not modified" in str(e):
            await query.answer()
            return
        raise

def _job_name(user_id: int, tid: int) -> str:
    return f"rem:{user_id}:{tid}"

def _cancel_reminder(app: Application, user_id: int, tid: int) -> None:
    for job in app.job_queue.get_jobs_by_name(_job_name(user_id, tid)):
        job.schedule_removal()

def _schedule_reminder(app: Application, user_id: int, tid: int, interval: int) -> None:
    _cancel_reminder(app, user_id, tid)
    app.job_queue.run_repeating(
        reminder_tick,
        interval=interval,
        first=interval,
        name=_job_name(user_id, tid),
        data={"user_id": user_id, "tid": tid},
    )

async def reminder_tick(context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id = context.job.data["user_id"]
    tid = context.job.data["tid"]
    data = load_tasks(user_id)
    t = data["tasks"].get(str(tid))
    if not t:
        _cancel_reminder(context.application, user_id, tid)
        return
    text = f"–ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ –ø–æ –∑–∞–¥–∞—á–µ: {t['name']}\n–û—Ç–∫—Ä—ã—Ç—å, –ø—Ä–æ–¥–ª–∏—Ç—å –∏–ª–∏ –æ—Ç–∫–ª—é—á–∏—Ç—å?"
    kb = InlineKeyboardMarkup([
        [
            InlineKeyboardButton("üîî +1—á", callback_data=f"t:rem1:{tid}"),
            InlineKeyboardButton("üîî +3—á", callback_data=f"t:rem3:{tid}"),
            InlineKeyboardButton("üîî +6—á", callback_data=f"t:rem6:{tid}"),
        ],
        [
            InlineKeyboardButton("–û—Ç–∫—Ä—ã—Ç—å –∫–∞—Ä—Ç–æ—á–∫—É", callback_data=f"t:open:{tid}"),
            InlineKeyboardButton("üîï –í—ã–∫–ª", callback_data=f"t:remoff:{tid}"),
        ],
    ])
    try:
        await context.bot.send_message(chat_id=user_id, text=text, reply_markup=kb)
    except Exception:
        pass

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    context.user_data["awaiting"] = None
    text = (
        "–ü—Ä–∏–≤–µ—Ç! –≠—Ç–æ –º–∏–Ω–∏–º–∞–ª–∏—Å—Ç–∏—á–Ω—ã–π —Ç—Ä–µ–∫–µ—Ä –∑–∞–¥–∞—á –¥–ª—è –°–î–í–ì –≤ Telegram.\n"
        "–°–æ–∑–¥–∞–≤–∞–π –∑–∞–¥–∞—á–∏ —Å —à–∞–≥–∞–º–∏, –æ—Ç–º–µ—á–∞–π –ø—Ä–æ–≥—Ä–µ—Å—Å –∫–Ω–æ–ø–∫–∞–º–∏, —Å–º–æ—Ç—Ä–∏ —Å–ø–∏—Å–æ–∫ –∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É.\n\n"
        "–ö–æ–º–∞–Ω–¥—ã:\n"
        "/new –ù–∞–∑–≤–∞–Ω–∏–µ |5 ‚Äî —Å–æ–∑–¥–∞—Ç—å –∑–∞–¥–∞—á—É —Å 5 —à–∞–≥–∞–º–∏\n"
        "/list ‚Äî –ø–æ–∫–∞–∑–∞—Ç—å —Å–ø–∏—Å–æ–∫\n"
        "/stats ‚Äî –ø–æ–∫–∞–∑–∞—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É"
    )
    if update.message:
        await update.message.reply_text(text, reply_markup=main_menu_kb())
    else:
        await safe_edit(update.callback_query, text, reply_markup=main_menu_kb())

async def help_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    await start(update, context)

async def stats_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id = update.effective_user.id
    data = load_tasks(user_id)
    opened = len(data["tasks"])
    closed = data["stats"]["closed"]
    await update.message.reply_text(f"–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞: –æ—Ç–∫—Ä—ã—Ç—ã—Ö {opened}, –∑–∞–∫—Ä—ã—Ç—ã—Ö {closed}", reply_markup=main_menu_kb())

async def new_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id = update.effective_user.id
    data = load_tasks(user_id)
    raw = " ".join(context.args) if context.args else ""
    if not raw:
        context.user_data["awaiting"] = {"mode": "new"}
        await update.message.reply_text(
            "–í–≤–µ–¥–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –∑–∞–¥–∞—á–∏. –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —à–∞–≥–æ–≤, –Ω–∞–ø—Ä–∏–º–µ—Ä: –ú–æ–Ω—Ç–∞–∂ –ø–æ–¥–∫–∞—Å—Ç–∞ |7",
            reply_markup=main_menu_kb()
        )
        return
    name, total = parse_new_payload(raw)
    data["seq"] += 1
    tid = data["seq"]
    data["tasks"][str(tid)] = {"id": tid, "name": name, "done": 0, "total": total, "reminder_interval": None}
    save_tasks(user_id, data)
    await update.message.reply_text(
        f"–°–æ–∑–¥–∞–Ω–æ: {task_line(data['tasks'][str(tid)])}",
        reply_markup=task_kb(tid, data["tasks"][str(tid)])
    )

async def list_cmd(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id = update.effective_user.id
    data = load_tasks(user_id)
    opened = len(data["tasks"])
    closed = data["stats"]["closed"]
    if not data["tasks"]:
        txt = f"–ü–æ–∫–∞ –Ω–µ—Ç –∑–∞–¥–∞—á. –û—Ç–∫—Ä—ã—Ç—ã—Ö {opened}, –∑–∞–∫—Ä—ã—Ç—ã—Ö {closed}.\n–ù–∞–∂–º–∏ ¬´‚ûï –ó–∞–¥–∞—á–∞¬ª –∏–ª–∏ –∫–æ–º–∞–Ω–¥–∞ /new –ù–∞–∑–≤–∞–Ω–∏–µ |5"
        if update.message:
            await update.message.reply_text(txt, reply_markup=main_menu_kb())
        else:
            await safe_edit(update.callback_query, txt, reply_markup=main_menu_kb())
        return
    lines = [f"–û—Ç–∫—Ä—ã—Ç—ã—Ö: {opened} | –ó–∞–∫—Ä—ã—Ç—ã—Ö: {closed}", ""]
    keyboard = []
    for sid, t in sorted(data["tasks"].items(), key=lambda x: int(x[0])):
        tid = int(sid)
        lines.append(f"{tid}. {task_line(t)}")
        keyboard.append([InlineKeyboardButton(f"–û—Ç–∫—Ä—ã—Ç—å: {t['name']}", callback_data=f"t:open:{tid}")])
    text = "\n".join(lines)
    kb = InlineKeyboardMarkup(keyboard + [[InlineKeyboardButton("‚¨ÖÔ∏è –ú–µ–Ω—é", callback_data="ui:menu")]])
    if update.message:
        await update.message.reply_text(text, reply_markup=kb)
    else:
        await safe_edit(update.callback_query, text, reply_markup=kb)

async def on_buttons(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    q = update.callback_query
    await q.answer()
    user_id = update.effective_user.id
    data = load_tasks(user_id)
    if not q.data:
        return
    if q.data == "ui:menu":
        context.user_data["awaiting"] = None
        await safe_edit(q, "–ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é", reply_markup=main_menu_kb())
        return
    if q.data == "ui:new":
        context.user_data["awaiting"] = {"mode": "new"}
        await safe_edit(
            q,
            "–í–≤–µ–¥–∏ –Ω–∞–∑–≤–∞–Ω–∏–µ –Ω–æ–≤–æ–π –∑–∞–¥–∞—á–∏. –ú–æ–∂–Ω–æ —Ç–∞–∫: –°—Ü–µ–Ω–∞—Ä–∏–π –≤—ã–ø—É—Å–∫–∞ |6",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("‚¨ÖÔ∏è –ú–µ–Ω—é", callback_data="ui:menu")]])
        )
        return
    if q.data == "ui:list":
        await list_cmd(update, context)
        return
    if q.data == "noop":
        return

    if q.data.startswith("t:rem:"):
        try:
            _, _, sid = q.data.split(":")
            tid = int(sid)
        except Exception:
            return
        t = data["tasks"].get(str(tid))
        if not t:
            await safe_edit(q, "–≠—Ç–∞ –∑–∞–¥–∞—á–∞ —É–∂–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç.", reply_markup=main_menu_kb())
            return
        await safe_edit(q, f"–ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –¥–ª—è: {t['name']}\n–í—ã–±–µ—Ä–∏ –∏–Ω—Ç–µ—Ä–≤–∞–ª –∏–ª–∏ –æ—Ç–∫–ª—é—á–∏.", reply_markup=reminder_menu_kb(tid))
        return

    parts = q.data.split(":")
    try:
        if len(parts) == 3:
            _, action, sid = parts
            tid = int(sid)
        elif len(parts) == 4:
            _, action, _, sid = parts
            tid = int(sid)
        else:
            return
    except Exception:
        return

    t = data["tasks"].get(str(tid))
    if action not in {"rem1", "rem3", "rem6", "remoff"} and not t and action not in {"close"}:
        await safe_edit(q, "–≠—Ç–∞ –∑–∞–¥–∞—á–∞ —É–∂–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç.", reply_markup=main_menu_kb())
        return

    if action in {"rem1", "rem3", "rem6"}:
        interval = REM_OPTIONS[action[-1]]
        if t:
            t["reminder_interval"] = interval
            save_tasks(user_id, data)
        _schedule_reminder(context.application, user_id, tid, interval)
        await safe_edit(q, f"–ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ: –∫–∞–∂–¥—ã–µ {action[-1]}—á.", reply_markup=InlineKeyboardMarkup([
            [InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –∫ –∑–∞–¥–∞—á–µ", callback_data=f"t:open:{tid}")],
            [InlineKeyboardButton("üîï –û—Ç–∫–ª—é—á–∏—Ç—å", callback_data=f"t:remoff:{tid}")]
        ]))
        return

    if action == "remoff":
        if t:
            t["reminder_interval"] = None
            save_tasks(user_id, data)
        _cancel_reminder(context.application, user_id, tid)
        await safe_edit(q, "–ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è –æ—Ç–∫–ª—é—á–µ–Ω—ã.", reply_markup=InlineKeyboardMarkup([
            [InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –∫ –∑–∞–¥–∞—á–µ", callback_data=f"t:open:{tid}")],
        ]))
        return

    if action == "open":
        await safe_edit(q, task_line(t), reply_markup=task_kb(tid, t))
        return

    if action == "+":
        t["done"] = min(t["done"] + 1, t["total"])
    elif action == "-":
        t["done"] = max(t["done"] - 1, 0)
    elif action == "ren":
        context.user_data["awaiting"] = {"mode": "rename", "id": tid}
        await safe_edit(q, "–í–≤–µ–¥–∏ –Ω–æ–≤–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –∑–∞–¥–∞—á–∏:", reply_markup=InlineKeyboardMarkup([
            [InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data=f"t:open:{tid}")]
        ]))
        return
    elif action == "set":
        context.user_data["awaiting"] = {"mode": "settotal", "id": tid}
        await safe_edit(q, "–í–≤–µ–¥–∏ –Ω–æ–≤–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —à–∞–≥–æ–≤ (—Ü–µ–ª–æ–µ —á–∏—Å–ª–æ ‚â• 1):", reply_markup=InlineKeyboardMarkup([
            [InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data=f"t:open:{tid}")]
        ]))
        return
    elif action == "rst":
        t["done"] = 0
    elif action == "del":
        _cancel_reminder(context.application, user_id, tid)
        del data["tasks"][str(tid)]
        save_tasks(user_id, data)
        await list_cmd(update, context)
        return
    elif action == "close":
        _cancel_reminder(context.application, user_id, tid)
        del data["tasks"][str(tid)]
        data["stats"]["closed"] = int(data["stats"].get("closed", 0)) + 1
        save_tasks(user_id, data)
        await list_cmd(update, context)
        return

    save_tasks(user_id, data)
    await safe_edit(q, task_line(t), reply_markup=task_kb(tid, t))

async def on_text(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id = update.effective_user.id
    awaiting = context.user_data.get("awaiting")
    if awaiting:
        mode = awaiting.get("mode")
        data = load_tasks(user_id)
        if mode == "new":
            name, total = parse_new_payload(update.message.text)
            data["seq"] += 1
            tid = data["seq"]
            data["tasks"][str(tid)] = {"id": tid, "name": name, "done": 0, "total": total, "reminder_interval": None}
            save_tasks(user_id, data)
            context.user_data["awaiting"] = None
            await update.message.reply_text(
                f"–°–æ–∑–¥–∞–Ω–æ: {task_line(data['tasks'][str(tid)])}",
                reply_markup=task_kb(tid, data["tasks"][str(tid)])
            )
            return
        if mode == "rename":
            tid = int(awaiting["id"])
            t = data["tasks"].get(str(tid))
            if t:
                t["name"] = update.message.text.strip() or t["name"]
                save_tasks(user_id, data)
                await update.message.reply_text(task_line(t), reply_markup=task_kb(tid, t))
            context.user_data["awaiting"] = None
            return
        if mode == "settotal":
            tid = int(awaiting["id"])
            t = data["tasks"].get(str(tid))
            if t:
                try:
                    new_total = max(1, int(update.message.text.strip()))
                    t["total"] = new_total
                    if t["done"] > new_total:
                        t["done"] = new_total
                    save_tasks(user_id, data)
                    await update.message.reply_text(task_line(t), reply_markup=task_kb(tid, t))
                except Exception:
                    await update.message.reply_text("–ù—É–∂–Ω–æ —Ü–µ–ª–æ–µ —á–∏—Å–ª–æ ‚â• 1. –ü–æ–ø—Ä–æ–±—É–π –µ—â—ë —Ä–∞–∑.")
                    return
            context.user_data["awaiting"] = None
            return
    await update.message.reply_text("–í—ã–±–µ—Ä–∏ –¥–µ–π—Å—Ç–≤–∏–µ:", reply_markup=main_menu_kb())

async def on_error(update: object, context: ContextTypes.DEFAULT_TYPE) -> None:
    err = context.error
    if isinstance(err, BadRequest) and "Message is not modified" in str(err):
        return
    print("ERROR:", err)

def _restore_reminders(app: Application) -> None:
    for fp in DATA_DIR.glob("*.json"):
        try:
            user_id = int(fp.stem)
        except ValueError:
            continue
        data = load_tasks(user_id)
        for sid, t in data["tasks"].items():
            interval = t.get("reminder_interval")
            if interval:
                _schedule_reminder(app, user_id, int(sid), int(interval))

def make_app() -> Application:
    return Application.builder().token(TOKEN).build()

def main() -> None:
    app = make_app()
    app.add_handler(CommandHandler("start", start))
    app.add_handler(CommandHandler("help", help_cmd))
    app.add_handler(CommandHandler("new", new_cmd))
    app.add_handler(CommandHandler("list", list_cmd))
    app.add_handler(CommandHandler("stats", stats_cmd))
    app.add_handler(CallbackQueryHandler(on_buttons))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, on_text))
    app.add_error_handler(on_error)

    _restore_reminders(app)

    public_url = os.getenv("PUBLIC_URL")
    if public_url:
        port = int(os.getenv("PORT", "8080"))
        path = os.getenv("WEBHOOK_PATH", "/hook")
        app.run_webhook(
            listen="0.0.0.0",
            port=port,
            url_path=path,
            webhook_url=f"{public_url}{path}",
            drop_pending_updates=True,
            allowed_updates=Update.ALL_TYPES,
        )
    else:
        app.run_polling(drop_pending_updates=True, allowed_updates=Update.ALL_TYPES)

if __name__ == "__main__":
    main()
